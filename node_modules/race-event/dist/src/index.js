/**
 * @packageDocumentation
 *
 * Race an event against an AbortSignal, taking care to remove any event
 * listeners that were added.
 *
 * @example
 *
 * ```TypeScript
 * const { raceEvent } = require('race-event')
 *
 * const controller = new AbortController()
 * const emitter = new EventTarget()
 *
 * setTimeout(() => {
 *   controller.abort()
 * }, 500)
 *
 * setTimeout(() => {
 *   // too late
 *   emitter.dispatchEvent(new CustomEvent('event'))
 * }, 1000)
 *
 * // throws an AbortError
 * const resolve = await raceEvent(emitter, 'event', controller.signal)
 * ```
 */
/**
 * An abort error class that extends error
 */
export class AbortError extends Error {
    type;
    code;
    constructor(message, code) {
        super(message ?? 'The operation was aborted');
        this.type = 'aborted';
        this.name = 'AbortError';
        this.code = code ?? 'ABORT_ERR';
    }
}
/**
 * Race a promise against an abort signal
 */
export async function raceEvent(emitter, eventName, signal, opts) {
    // create the error here so we have more context in the stack trace
    const error = new AbortError(opts?.errorMessage, opts?.errorCode);
    if (signal?.aborted === true) {
        return Promise.reject(error);
    }
    return new Promise((resolve, reject) => {
        const eventListener = (evt) => {
            if (opts?.filter?.(evt) === false) {
                return;
            }
            emitter.removeEventListener(eventName, eventListener);
            signal?.removeEventListener('abort', abortListener);
            resolve(evt);
        };
        const abortListener = () => {
            emitter.removeEventListener(eventName, eventListener);
            signal?.removeEventListener('abort', abortListener);
            reject(error);
        };
        emitter.addEventListener(eventName, eventListener);
        signal?.addEventListener('abort', abortListener);
    });
}
//# sourceMappingURL=index.js.map